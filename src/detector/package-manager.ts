import type { FileSystem } from "./index.js";
import type { PackageManager } from "./types.js";

/**
 * Detect the package manager from lockfile presence.
 *
 * Lockfiles are the most reliable signal â€” they're generated by the package manager
 * and committed to the repo. Order matters: check more specific signals first.
 */
export async function detectPackageManager(
  projectPath: string,
  fs: FileSystem,
): Promise<PackageManager | null> {
  // Node.js package managers (check lockfiles in specificity order)
  const nodeLockfiles: Array<{ file: string; manager: PackageManager }> = [
    { file: "bun.lockb", manager: "bun" },
    { file: "pnpm-lock.yaml", manager: "pnpm" },
    { file: "yarn.lock", manager: "yarn" },
    { file: "package-lock.json", manager: "npm" },
  ];

  for (const { file, manager } of nodeLockfiles) {
    if (await fs.exists(`${projectPath}/${file}`)) {
      return manager;
    }
  }

  // Python package managers (check lockfiles/configs in specificity order)
  const pythonSignals: Array<{ file: string; manager: PackageManager }> = [
    { file: "uv.lock", manager: "uv" },
    { file: "poetry.lock", manager: "poetry" },
    { file: "Pipfile.lock", manager: "pipenv" },
    { file: "Pipfile", manager: "pipenv" },
  ];

  for (const { file, manager } of pythonSignals) {
    if (await fs.exists(`${projectPath}/${file}`)) {
      return manager;
    }
  }

  // Fallback: if pyproject.toml exists with [tool.poetry], it's poetry
  const pyprojectContent = await fs.readFile(`${projectPath}/pyproject.toml`);
  if (pyprojectContent !== null) {
    if (pyprojectContent.includes("[tool.poetry]")) {
      return "poetry";
    }
    // If pyproject.toml exists but no lockfile, assume pip
    return "pip";
  }

  // If only requirements.txt exists, it's pip
  if (await fs.exists(`${projectPath}/requirements.txt`)) {
    return "pip";
  }

  // If only package.json exists (no lockfile), assume npm
  if (await fs.exists(`${projectPath}/package.json`)) {
    return "npm";
  }

  return null;
}
